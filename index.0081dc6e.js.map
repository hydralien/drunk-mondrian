{"mappings":"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","sources":["js/main.js"],"sourcesContent":["let drawTimeOut = null;\nlet paintTimeOut = null;\nlet nextDrawingStep = () => {};\nlet nextPaintingStep = () => {};\nlet delay = 30;\n\nconst border = 70;\nconst defaultStep = 1; // position increment\nconst velocityJump = 20;\n\nfunction drawNextEventual(context, posX, posY, velX, velY, targetVelX, targetVelY) {\n  if (Math.abs(velX) >= Math.abs(targetVelX)) {\n    targetVelX = Math.random() * velocityJump * (Math.random() > 0.5 ? 1 : -1);\n  }\n  if (Math.abs(velY) >= Math.abs(targetVelY)) {\n    targetVelY = Math.random() * velocityJump * (Math.random() > 0.5 ? 1 : -1);\n  }\n\n  const borderStepReduce = 0.1;\n  let stepX = defaultStep;// + Math.random() * 3;\n  let stepY = defaultStep;// + Math.random() * 3;\n  // Push target back from the rim if position reaches border area\n  if (posX < border) {\n    targetVelX = Math.abs(targetVelX);\n    stepX += (border - posX) * borderStepReduce;\n  }\n  if (posX > context.canvas.width - border) {\n    targetVelX = 0 - Math.abs(targetVelX);\n    stepX += (posX - (context.canvas.width - border)) * borderStepReduce;\n  }\n  if (posY < border) {\n    targetVelY = Math.abs(targetVelY);\n    stepY += (border - posY) * borderStepReduce;\n  }\n  if (posY > context.canvas.height - border) {\n    targetVelY = 0 - Math.abs(targetVelY);\n    stepY += (posY - (context.canvas.height - border)) * borderStepReduce;\n  }\n\n  velX = velX < targetVelX ? velX + stepX : velX - stepX;\n  velY = velY < targetVelY ? velY + stepY : velY - stepY;\n\n  const nextX = Math.floor(posX + velX);\n  const nextY = Math.floor(posY + velY);\n\n  if (nextX !== posX || nextY !== posY) {\n    const [pixelR, pixelG, pixelB, pixelA] = context.getImageData(nextX, nextY, 1, 1).data;\n    if (pixelR + pixelB + pixelG === 0 && pixelA === 255) {\n      // The idea here is to detect when the line intersects another line and do the painting then.\n      // However, it requires quite a bit of extra work: lines are larger then pixel so intersection is hard to detect,\n      // there could be multi-line intersection, direction where line came from needs some logic to understand\n      // where to start painting and so on. For now, painting is just random guessing.\n      // console.log('XING');\n      // spreadPaint(context, 1);\n    }\n  }\n\n  context.beginPath();\n  context.moveTo(posX, posY);\n\n  context.lineTo(nextX, nextY);\n\n  context.stroke();\n\n  nextDrawingStep = () => drawNextEventual(context, nextX, nextY, velX, velY, targetVelX, targetVelY);\n  drawTimeOut = setTimeout(nextDrawingStep, delay);\n}\n\n// Deprecated, but still around for the reference - draws straight lines instead of smooth\nfunction drawNext(context, posX, posY, velX, velY) {\n  const nextX = Math.floor(posX + 100 * velX);\n  const nextY = Math.floor(posY + 100 * velY);\n\n  context.beginPath();\n  context.moveTo(posX, posY);\n\n  context.lineTo(nextX, nextY);\n\n  context.stroke();\n\n  if (Math.random() < 0.1) {\n      velX = Math.random() / 10 * (Math.random() > 0.5 ? 1 : -1);\n  }\n\n  if (Math.random() < 0.1) {\n    velY = Math.random() / 10 * (Math.random() > 0.5 ? 1 : -1);\n  }\n\n  let nextVelX = velX;\n  let nextVelY = velY;\n\n  if (nextX < border) nextVelX = Math.abs(velX);\n  if (nextX > context.canvas.width - border) nextVelX = 0 - Math.abs(velX);\n  if (nextY < border) nextVelY = Math.abs(velY);\n  if (nextY > context.canvas.height - border) nextVelY = 0 - Math.abs(velY);\n\n  drawTimeOut = setTimeout(() => drawNext(context, nextX, nextY, nextVelX, nextVelY), delay);\n}\n\nfunction drawing(context) {\n  context.fillStyle = \"#FF0000\";\n  context.lineWidth = 3;\n  context.strokeStyle = \"#000000\";\n\n  const startX = Math.floor(Math.random() * context.canvas.width);\n  const startY = Math.floor(Math.random() * context.canvas.height);\n\n  // drawNext(context, startX, startY, 0.01, -0.01)\n  nextDrawingStep = () => drawNextEventual(context, startX, startY, 1, 1, 1, 1);\n  nextPaintingStep = () => spreadPaint(context, 1);\n  toggleDraw();\n}\n\nfunction toggleDraw() {\n  const toggleButton = document.getElementById('draw-toggle');\n\n  if (drawTimeOut !== null) {\n    clearTimeout(drawTimeOut);\n    drawTimeOut = null;\n    toggleButton.innerText = \"Start drawing\";\n  } else {\n    drawTimeOut = setTimeout(nextDrawingStep, delay);\n    toggleButton.innerText = \"Stop drawing\";\n  }\n}\n\nfunction togglePaint() {\n  const toggleButton = document.getElementById('paint-toggle');\n\n  if (paintTimeOut !== null) {\n    clearTimeout(paintTimeOut);\n    paintTimeOut = null;\n    toggleButton.innerText = \"Start painting\";\n  } else {\n    paintTimeOut = setTimeout(nextPaintingStep, delay);\n    toggleButton.innerText = \"Stop painting\";\n  }\n}\n\nfunction changeDelay(event) {\n  const selector = document.getElementById('delay-selector');\n  delay = selector.value;\n}\n\nfunction spreadPaint(context, pointCount) {\n  if (!pointCount) pointCount = 10;\n\n  if (!context) {\n    const canvasElement = document.getElementById('drawing-canvas');\n    context = canvasElement.getContext(\"2d\");\n  }\n\n  const maxHeight = context.canvas.height;\n  const maxWidth = context.canvas.width;\n\n  const colorSet = [ // R, G, B, A\n    [255, 0, 0, 255], // red\n    [0, 255, 0, 255], // green\n    [0, 0, 255, 255], // blue\n    [255, 255, 0, 255], // yellow\n    [0, 0, 0, 255], // black\n  ];\n\n  for (let pointNo = 1; pointNo <= pointCount; pointNo += 1) {\n    const randX = Math.floor(Math.random() * maxWidth);\n    const randY = Math.floor(Math.random() * maxHeight);\n\n    let paintColor = colorSet[pointNo % colorSet.length];\n    if (pointCount < colorSet.length) {\n      paintColor = colorSet[Math.floor(Math.random() * colorSet.length)];\n    }\n\n    bucketFill(context, randX, randY, paintColor);\n  }\n\n  nextPaintingStep = () => spreadPaint(context, pointCount);\n  paintTimeOut = setTimeout(nextPaintingStep, delay);\n}\n\nfunction bucketFill(context, posX, posY, fillColor) {\n  const maxHeight = context.canvas.clientHeight;\n  const maxWidth = context.canvas.clientWidth;\n  const maxPaintArea = Math.floor((maxWidth / 10) * (maxHeight / 10));\n\n  // console.log(`Bucket at ${posX}:${posY} max ${maxPaintArea} with `, fillColor);\n\n  const currentPoint = context.getImageData(posX, posY, 1, 1).data;\n  if (currentPoint[3] !== 0) {\n    // console.log(\"Point already painted with \", currentPoint);\n    return;\n  }\n\n  const fillKeyGen = (keyX,keyY) => `${keyX}:${keyY}`;\n  const fillList = {};\n  const cellStack = [[posX, posY]];\n  fillList[fillKeyGen(posX, posY)] = [posX, posY];\n  let paintArea = 0;\n\n  while (cellStack.length > 0 && paintArea < maxPaintArea) {\n    const [currentX, currentY] = cellStack.shift();\n\n    for (let checkX = currentX - 1; checkX <= currentX + 1; checkX += 1) {\n      if (checkX < 0 || checkX > maxWidth) continue;\n\n      for (let checkY = currentY - 1; checkY <= currentY + 1; checkY += 1) {\n        if (checkY < 0 || checkY > maxHeight) continue;\n\n        const fillKey = fillKeyGen(checkX, checkY);\n        if (fillList[fillKey]) continue;\n\n        // check if already painted\n        const paintPoint = context.getImageData(checkX, checkY, 1, 1).data;\n        if (paintPoint[3] !== 0) continue;\n\n        const pointCoords = [checkX, checkY];\n        fillList[fillKey] = pointCoords;\n        cellStack.push(pointCoords);\n        paintArea += 1;\n      }\n    }\n  }\n\n  if (paintArea >= maxPaintArea) {\n    // console.log(`Area too large, max ${maxPaintArea}`);\n    return;\n  }\n\n  // console.log(`Paint it over ${paintArea}`);\n  for (const [paintX, paintY] of Object.values(fillList)) {\n    const imageData = new ImageData(new Uint8ClampedArray(fillColor), 1, 1);\n    context.putImageData(imageData, paintX, paintY);\n  }\n}\n\nfunction init() {\n  const canvasHolder = document.getElementById('canvas-container');\n\n  const containerWidth = canvasHolder.clientWidth || 1000;\n  const containerHeight = canvasHolder.clientHeight || 800;\n\n  const canvas = document.createElement('canvas');\n  canvas.id = \"drawing-canvas\";\n  canvas.width = containerWidth;\n  canvas.height = containerHeight;\n\n  canvasHolder.appendChild(canvas);\n\n  drawing(canvas.getContext(\"2d\"));\n}\n\ninit();\n"],"names":["drawTimeOut","paintTimeOut","nextDrawingStep","nextPaintingStep","delay","border","defaultStep","velocityJump","drawNextEventual","context","posX","posY","velX","velY","targetVelX","targetVelY","Math","abs","random","borderStepReduce","stepX","stepY","canvas","width","height","nextX","floor","nextY","pixelR","pixelG","pixelB","pixelA","getImageData","data","beginPath","moveTo","lineTo","stroke","setTimeout","drawNext","nextVelX","nextVelY","drawing","fillStyle","lineWidth","strokeStyle","startX","startY","spreadPaint","toggleDraw","toggleButton","document","getElementById","clearTimeout","innerText","togglePaint","changeDelay","event","selector","value","pointCount","canvasElement","getContext","maxHeight","maxWidth","colorSet","pointNo","randX","randY","paintColor","length","bucketFill","fillColor","clientHeight","clientWidth","maxPaintArea","fillKeyGen","keyX","keyY","fillList","cellStack","paintArea","currentX","currentY","shift","checkX","checkY","fillKey","pointCoords","push","paintX","paintY","Object","values","imageData","ImageData","Uint8ClampedArray","putImageData","init","canvasHolder","containerWidth","containerHeight","createElement","id","appendChild"],"version":3,"file":"index.0081dc6e.js.map"}